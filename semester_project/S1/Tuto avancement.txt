
pyenv activate cw

jupyter notebook (at /home/gata/chipwhisperer)


----------------

0 - Introduction to Jupyter Notebooks

1 - Connecting to Hardware

target.read(), target.write(), target.flush()

-----------------

SCA101 : 
Lab 0
Lab 2_1A :


SCOPETYPE = 'OPENADC'
PLATFORM='CW308_STM32F4'
%%bash -s "$PLATFORM"
cd ../../../hardware/victims/firmware/simpleserial-base-lab2
make PLATFORM=$1 CRYPTO_TARGET=NONE

cw.program_target(scope, prog, "../../../hardware/victims/firmware/simpleserial-base-lab2/simpleserial-base-{}.hex".format(PLATFORM))

capture_trace

HINT: In order to measure current, ChipWhisperer measures voltage drop across a shunt resistor. This means that the power trace is actually inverted (aka large negative swings are areas of higher power consumption).

Lab 2_1B

%run "../../Setup_Scripts/Setup_Generic.ipynb"

order of high/low 

np.sum(np.abs

Lab 3_1

SCOPETYPE = 'OPENADC'
PLATFORM='CW308_STM32F4'
CRYPTO_TARGET='TINYAES128C'
SS_VER='SS_VER_1_1'

Lab 3_2

Bitwise Guessing Loop - calculate_diffs
loop over all traces, compute hyptohtical leakage and sort traces in function of it. Compute diff. 

Lab 3_3

DPA attack

Lab 4_1 

setting data takes power
more data that is set, the greater the average power draw

Hamming Weight

power to set bits is linear with nbr of bits

voltage will go DOWN for an INCREASE in current

We are measuring the drop across the shunt resistor. An increase in the current causes a higher voltage across the resistor. When no current flows there is no drop across the resistor. But since we only measure a single end of the resistor, we see a higher voltage when no current flows
-> take oppositite (*-1)

Lab 4_2

CPA (correlation attack)

Lab 4_3 

Analyzer makes launching a CPA attack much easier than our manual way. It also has the advantage of capturing some interesting data for us, and reporting the attack s



SCA201 : 
Lab 1_1A :
Resynchronizing Traces with Sum of Absolute Difference
EXTRA_OPTS=ADD_JITTER

Lab 1_1B :

 more complicated jitter can defeat the SAD resynchronization technique we used in the last lab. In response, we used the dynamic time warp preprocessor to perform a better resynchronization and defeat the jitter.
 
 Lab 2_1 :
  MBEDTLS takes, so we would be able to use the reverse T-Table to attack decryption.
  
 Lab 2_2 :
 
 LSACAR
 
 Lab 2_3 :
 
modified CPA attack, allowing our attack to succeed even with a MixColumns operation.

STM32F4 style implementations (which was vulnerable to last round state diff)

Lab 3_1A :
AES256 Bootloader 
Compute CRC
Own leakage model

AES CBC


We can trigger on a falling edge by changing scope.adc.basic_mode to "falling_edge":

DPA attack, timing attack

Lab 3_2B :
passed, not working

SCA202 :
SPA attack
power side-channel for performing RSA 8-bit attacks. We attacked it both using a SAD match to find the interesting points, and by performing a bandwidth-specific filter to make it more obvious when sections are 1 vs 0.

SCA203 :
TVLA can be used to assess a target's vulnerability to side channel attacks

assess this likelyhood, we'll use Welsh's T-Test:

TODO 
Fault 101

Fault 201
